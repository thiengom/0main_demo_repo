const path = require('path')
const fs = require('fs')
const cds = require('../../cds')

const BuildTaskHandlerInternal = require('../buildTaskHandlerInternal')
const { FOLDER_GEN } = require('../../constants')
const ResourcesTarBuilder = require('../mtx/resourcesTarBuilder')
const { BuildError } = require('../../util')

class MtxExtensionModuleBuilder extends BuildTaskHandlerInternal {
    init() {
        super.init()
        if (this.buildOptions.root === this.buildOptions.target) {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN)
        }
    }

    async build() {
        const { src, dest } = this.task
        const destExt = path.join(dest, 'ext')

        const packageJson = path.join(src, 'package.json')
        if (!fs.existsSync(packageJson)) {
            throw new BuildError(`The package.json file is missing`)
        }
        await this.copy(packageJson).to(path.join(destExt, 'package.json'))

        // validate existence of base model by simply checking existence of appPackage folder 
        // cds.resolve might fail for the extension migration use case as no index.csn file exists.
        // A compilation error is thrown anyhow if any base model using statement cannot be resolved.
        const appPackage = MtxExtensionModuleBuilder._getAppPackageName()
        if (!fs.existsSync(path.join(src, 'node_modules', appPackage))) {
            throw new BuildError(`The SaaS application base model '${appPackage}' is missing. Have you run the 'cds pull' command?`)
        }

        // copy handlers
        const folders = [path.join(src, cds.env.folders.srv, 'handlers')]
        await this.copyNativeContent(src, destExt, res => {
            if (fs.statSync(res).isDirectory()) {
                return folders.some(folder => folder.startsWith(res))
            }
            if (folders.includes(path.dirname(res)) && /\.js$/.test(res)) {
                return true
            }
        })

        const model = await this.model()
        if (model) {
            // extension CSN using parsed format
            const options = { ...this.options(), flavor: 'parsed' }
            const extCsn = await cds.load(this.resolveModel(), options)
            if (extCsn.requires) {
                extCsn.requires.length = 0
            }
            await this.compileToJson(extCsn, path.join(destExt, 'extension.csn'))

            await this.collectLanguageBundles(extCsn, path.join(destExt, 'i18n'))

            const files = Object.keys(await cds.deploy.resources(model))
            if (files.length > 0) {
                const dataDest = path.join(destExt, 'data')
                await Promise.all(
                    files
                        .filter(file => /\.csv$/.test(file))
                        .map(csv => {
                            return this.copy(csv).to(path.join(dataDest, path.basename(csv)))
                        })
                )
            }
        }
        // add all resources contained in the 'ext' folder
        await new ResourcesTarBuilder(this).writeTarFile(path.join(this.task.dest, 'extension.tgz'), destExt)
    }

    static _getAppPackageName() {
        return cds.env.extends || '_base';
    }
}
module.exports = MtxExtensionModuleBuilder
