
'use strict';

const { makeMessageFunction } = require('../base/messages');
const { checkCSNVersion } = require('../json/csnVersion');
const { getNamespace, forEachDefinition } = require('../model/csnUtils');
const { optionProcessor } = require('../optionProcessor');
const { isBetaEnabled } = require('../base/model');
const { transformForRelationalDBWithCsn } = require('../transform/forRelationalDB');


/**
 * FIXME: Not yet supported, only in beta mode
 * FIXME: This is not up-to-date in regards to the changes to hdbcds/sql quoting etc.
 *
 * Generate SQL DDL rename statements for a migration, renaming existing tables and their
 * columns so that they match the result of "toHana" or "toSql" with the 'plain' option for names.
 * Expects the naming convention of the existing tables to be either 'quoted' or 'hdbcds' (default).
 * The following options control what is actually generated (see help above):
 *   options : {
 *     sqlMapping :  existing names, either 'quoted' or 'hdbcds' (default)
 *   }
 * Return a dictionary of top-level artifacts by their names, like this:
 * { "foo" : "RENAME TABLE \"foo\" ...",
 *   "bar::wiz" : "RENAME VIEW \"bar::wiz\" ..."
 * }
 *
 * @todo clarify input parameters
 * @param {CSN.Model} inputCsn CSN?
 * @param {CSN.Options} options Transformation options
 * @returns {object} A dictionary of name: rename statement
 */
function toRename( inputCsn, options ) {
  const { error, warning, throwWithError } = makeMessageFunction(inputCsn, options, 'to.rename');

  // Merge options with defaults.
  options = Object.assign({ sqlMapping: 'hdbcds', sqlDialect: 'hana' }, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toRename').forEach(complaint => warning(null, null, `${complaint}`));
  checkCSNVersion(inputCsn, options);

  // Requires beta mode
  if (!isBetaEnabled(options, 'toRename'))
    error(null, null, 'Generation of SQL rename statements is not supported yet (only in beta mode)');

  // FIXME: Currently, 'toRename' implies transformation for HANA (transferring the options to forRelationalDB)
  const csn = transformForRelationalDBWithCsn(inputCsn, options, 'to.rename');
  // forRelationalDB looses empty contexts and services, add them again so that toRename can calculate the namespaces
  forEachDefinition(csn, (artifact, artifactName) => {
    if ((artifact.kind === 'context' || artifact.kind === 'service') && csn.definitions[artifactName] === undefined)
      csn.definitions[artifactName] = artifact;
  });

  const result = Object.create(null);

  // Render each artifact on its own
  for (const artifactName in csn.definitions) {
    const sourceStr = renameTableAndColumns(artifactName, csn.definitions[artifactName]);
    if (sourceStr !== '')
      result[artifactName] = sourceStr;
  }

  throwWithError();

  return {
    rename: result,
    options,
  };

  /**
   * If 'art' is a non-view entity, generate SQL statements to rename the corresponding
   * table and its columns from the naming conventions given in 'options.sqlMapping'
   * (either 'quoted' or 'hdbcds') to 'plain'. In addition, drop any existing associations
   * from the columns (they would likely become invalid anyway).
   * Do not rename anything if the names are identical.
   *
   * @param {string} artifactName Name of the artifact to rename
   * @param {CSN.Artifact} art CSN artifact
   * @returns {string} RENAME statements
   */
  function renameTableAndColumns( artifactName, art ) {
    let resultStr = '';
    if (art.kind === 'entity' && !art.query) {
      const beforeTableName = quoteSqlId(absoluteCdsName(artifactName));
      const afterTableName = plainSqlId(artifactName);

      if (beforeTableName !== afterTableName)
        resultStr += `  EXEC 'RENAME TABLE ${beforeTableName} TO ${afterTableName}';\n`;


      resultStr += Object.keys(art.elements).map((name) => {
        const e = art.elements[name];
        let str = '';

        const beforeColumnName = quoteSqlId(name);
        const afterColumnName = plainSqlId(name);

        if (!e._ignore) {
          if (e.target)
            str = `  EXEC 'ALTER TABLE ${afterTableName} DROP ASSOCIATION ${beforeColumnName}';\n`;

          else if (beforeColumnName !== afterColumnName)
            str = `    EXEC 'RENAME COLUMN ${afterTableName}.${beforeColumnName} TO ${afterColumnName}';\n`;
        }
        return str;
      }).join('');
    }
    return resultStr;
  }

  /**
   * Return 'name' in the form of an absolute CDS name - for the 'hdbcds' naming convention,
   * this means converting '.' to '::' on the border between namespace and top-level artifact.
   * For all other naming conventions, this is a no-op.
   *
   * @param {string} name Name to absolutify
   * @returns {string} Absolute name
   */
  function absoluteCdsName( name ) {
    if (options.sqlMapping !== 'hdbcds')
      return name;

    const namespaceName = getNamespace(inputCsn, name);
    if (namespaceName)
      return `${namespaceName}::${name.substring(namespaceName.length + 1)}`;

    return name;
  }

  /**
   * Return 'name' with appropriate "-quotes, also replacing '::' by '.' if 'options.sqlMapping'
   * is 'quoted'
   *
   * @param {string} name Name to quote
   * @returns {string} Quoted string
   */
  function quoteSqlId( name ) {
    if (options.sqlMapping === 'quoted')
      name = name.replace(/::/g, '.');

    return `"${name.replace(/"/g, '""')}"`;
  }

  /**
   * Return 'name' with uppercasing and appropriate "-quotes, also replacing '::' and '.' by '_'
   * (to be used by 'plain' naming convention).
   *
   * @param {string} name Name to turn into a plain identifier
   * @returns {string} A plain SQL identifier
   */
  function plainSqlId( name ) {
    return `"${name.toUpperCase().replace(/(::|\.)/g, '_').replace(/"/g, '""')}"`;
  }
}

module.exports = {
  toRename,
};
