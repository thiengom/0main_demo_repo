const cds = require('../../cds')
const { Worker } = require('worker_threads')
const path = require('node:path')
const { timeout, resourceLimits } = require('./config')
const workerPath = path.resolve(__dirname, 'worker.js')
const { Errors } = require('../../../../lib/req/response')
const LOG = cds.log()

const _getReqData = req => {
  return {
    data: req.data,
    params: req.params,
    results: req.results,
    messages: req.messages,
    errors: req.errors ?? new Errors()
  }
}

module.exports = async function executeCode(code, req) {
  const reqData = _getReqData(req)
  const srv = this
  const _getTarget = target => {
    switch (target) {
      case 'srv':
        return srv

      case 'req':
        return req

      // no default
    }
  }
  const workerId = cds.utils.uuid()
  const contextId = cds.utils.uuid()
  const worker = new Worker(workerPath, {
    workerData: { id: workerId },
    resourceLimits
  })

  const executePromise = new Promise(function executeCodePromiseExecutor(resolve, reject) {
    worker.on('online', onStarted)
    worker.on('message', onMessageReceived)
    worker.on('error', onError)
    worker.on('exit', onExit)

    let onStartTimeoutID

    function onStarted() {
      onStartTimeoutID = setTimeout(() => {
        worker.terminate()
        reject(new Error(`Script execution timed out after ${timeout}ms`))
      }, timeout)
    }

    function onMessageReceived(message) {
      if (LOG._debug)
        LOG.debug(`Post message received on main thread (code-ext/execute.js) from worker thread`, message)
      switch (message.kind) {
        case 'run':
          run(message)
          return

        case 'success':
          onSuccess(message)
          cleanup()
          return

        case 'error':
          onError(message.error)
          return

        // no default
      }
    }

    async function onSuccess(message) {
      for (const m of message.postMessages) await run(m)
      req.data && Object.assign(req.data, message.req.data) // REVISIT: Why Object.assign(...) is a required?
      req.results = message.req.results
      resolve(req.results ?? message.result)
    }

    function onError(error) {
      reject(error)
    }

    function onExit(exitCode) {
      if (exitCode !== 0) reject(new Error(`Worker thread stopped with exit code ${exitCode}`))
    }

    async function run(message) {
      try {
        let result = _getTarget(message.target)[message.prop](...message.args)
        if (typeof result?.then === 'function') result = await result
        if (message.responseData) worker.postMessage({ id: message.id, kind: 'responseData', result })
      } catch (error) {
        if (LOG._debug) LOG.debug(`Calling ${message.target}.${message.prop}(...) throws an error.`, error)
        worker.postMessage({ id: message.id, kind: 'cleanup' })
        reject(error)
      }
    }

    function cleanup() {
      clearTimeout(onStartTimeoutID)
      worker.terminate()
    }
  })

  // triggers execution of the code in the worker thread
  const message = { contextId, workerId, kind: 'start', code, reqData }
  worker.postMessage(message)
  return executePromise
}
